/* Evan French  CS 492/592  Winter 2017 */
/* Modified by Wu-chang Feng */
#include <stdio.h>
#include <fcntl.h>
#include <string.h>
#define USERDEF "AAAAAA"

#define USERDEF1 "Andigb"
#define USERDEF2 "wt1mbd"
#define USERDEF3 "ogpbb8"

char msg[] = \
"This level is designed to introduce you to radare2's disassembler.  The\n\
The binary has been stripped to make static analysis more difficult\n\
Load the binary by typing:\n\
  \"r2 <program name>\" \n\
Next, type \"aaa\" for \"analyze all\", then \"V\" to enter Visual mode,\n\
and finally press \"p\" until you see the disassembled instructions.  Go\n\
to main via \":s sym.main\".  Then, press \"V\" again to bring up a graphical\n\
IDA Pro-like view of the code via a browser tab.   Go back to the disassmbler\n\
view.  In it, see how function call instructions are annotated by numbers\n\
in brackets ([x]).  This allows one to \"jump\" to their code by typing the\n\
number.  To return from one of these jumps press \"u\". Go back to sym.main\n\
and scroll down towards the end of it to find calls to test functions.\n\
Somewhere within these calls, a comparison is done that will cause \n\
\"Good Job.\" to be printed.  Find this comparison and note its address.\n\
Then, restart using the radare2 debugger and use the instructions from the\n\
previous radare2 debugger level to bring up a window that has the assembly\n\
view, the register state, and the stack memory.  Find the two pointers to\n\
strings that are the arguments to strcmp on the stack.  Examine both of them\n\
via :ps @ <hex_address> to discover the password\n\n";

void print_msg() {
        printf("%s",msg);
}

int test_e(char buff[], char pass[]){
       int i;
       for (i = 0; i < 100; i++) {
	if (strcmp(buff,pass)) {
          return 0;
        }
       }
}

int test_c(char buff[], char pass[] ){
        char tmp;
        tmp = pass[4];
        pass[4] = pass[3];
        pass[3] = pass[2];
        pass[2] = tmp;
   	if (strcmp(buff,pass)) {
          printf ("Try again.\n");
        } else {
          printflag();
        }
}
int test_d(char buff[], char pass[]){
	test_c(buff,pass);
}
int test_b(char buff[], char pass[]){
       int i;
       for (i = 0; i < 100; i++) {
	if (strcmp(buff,pass)) {
          return 0;
        }
       }
}

int test_a(char buff[], char pass[] ){
   	if (strcmp(buff,pass)) {
          return 0;
        }
}

void printflag()
{
	int fd;
	int len;
	unsigned char data[128];

	fd = open("flag", O_RDONLY);

	if ( fd <= 0 ) {
		printf("Failed to open flag.\n");
		return;
	}

	len = lseek( fd, 0, SEEK_END);
	lseek(fd, 0, SEEK_SET);

	if ( len > 128 ) {
		len = 128;
	}

	memset(data, 0, 128);
	read( fd, data, len);
	close(fd);

	printf("%s\n", data);
	return;
}

int main(int argc, char* argv[]) {
    char buff[20];
    char pass[20];
    char c;
    int i;
    char pass1[20];
    char pass2[20];
    char pass3[20];


    print_msg();

    for (i=0; i < 20; i++){
	pass[i] = 0; 
    strncpy(pass,USERDEF,strlen(USERDEF));
    }
    for (i=0; i < 20; i++){
	pass1[i] = 0; 
    strncpy(pass1,USERDEF1,strlen(USERDEF));
    }
   for (i=0; i < 20; i++){
	pass2[i] = 0; 
    strncpy(pass2,USERDEF2,strlen(USERDEF));
    }
    for (i=0; i < 20; i++){
	pass3[i] = 0; 
    strncpy(pass3,USERDEF3,strlen(USERDEF));
    }

    printf("Enter the password: ");
    scanf("%8s",buff);

    test_a(buff, pass);
    test_b(buff, pass);
    test_d(buff, pass);
    test_e(buff, pass);

   return 0;

}
