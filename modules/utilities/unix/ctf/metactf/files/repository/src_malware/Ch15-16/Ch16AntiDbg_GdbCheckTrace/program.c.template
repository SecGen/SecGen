#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <time.h>
#include <signal.h>
#include <unistd.h>
#include <sys/ptrace.h>
#define USERDEF AAAAAA

int check=USERDEF;

/* This program implements some basic anti-debugging techniques as follows:

1.  Search /proc/PID/cmdline to see if there is a string gdb. PID is the parent id of current process (getppid())

2.  Similar to the last technique but search the file /proc/PID/status this time and try to find out the string gdb */

char msg[] =
 "In this level, several artifacts of GDB are checked before the binary is\n"
 "executed.  Specifically, command line checks and traces of gdb within\n"
 "/proc can reveal the presence of GDB.  Bypass each of these checks by\n"
 "jumping over them in the debugger.  Be careful what you skip over, however,\n"
 "as the passcode calculation is entangled within the functions that check for\n"
 "GDB.\n\n";

/* Symbolic execution trap */
void print_msg() {
  unsigned int i,h1,h2;
  unsigned int len=strlen(msg);
  for (i = 0; i < 100*len; i++) {
    h1 += msg[i%len] + msg[(i+1)%len];
    h2 += msg[(i+1)%len] + msg[(i+2)%len];
  }
  if (h1 == h2)
    printf("%s",msg);
  else
    printf("%s",msg);
}

void print_good(void){
                printflag();
}

void print_again(void){
                printf("Try again.\n");
}

/* Detect GDB by searching the /proc/PID/cmdline */
int cmdline_check(){
  char buf[20], label[20];
  FILE* fd;
  snprintf(buf, 20, "/proc/%d/cmdline", getppid());
  fd = fopen(buf, "r");
  fgets(label, 20, fd);
  if(strstr(label, "gdb") || strstr(label, "ltrace") || strstr(label, "strace")){
     //printf("cmdline debugged.\n");
     return 1;
  }
  check++;
  fclose(fd);
  return 0;
}

/* check /proc/PID/status */
int status_check(){
  char buf[20], label[20];
  FILE* fd;
  snprintf(buf, 20, "/proc/%d/status", getppid());
  fd = fopen(buf, "r");
  fgets(label, 20, fd);
  if(strstr(label, "gdb") || strstr(label, "ltrace") || strstr(label, "strace")) {
     //printf("status debugged.\n");
     return 1;
  }
  fclose(fd);
  check++;
  return 0;
}

void printflag()
{
	int fd;
	int len;
	unsigned char data[128];

	fd = open("flag", O_RDONLY);

	if ( fd <= 0 ) {
		printf("Failed to open flag.\n");
		return;
	}

	len = lseek( fd, 0, SEEK_END);
	lseek(fd, 0, SEEK_SET);

	if ( len > 128 ) {
		len = 128;
	}

	memset(data, 0, 128);
	read( fd, data, len);
	close(fd);

	printf("%s\n", data);
	return;
}

int main(int argc, char* argv[])
{
  int input;

  print_msg();

  if (cmdline_check() || status_check()) {
	print_again();
	return 0;
  }

  printf("Enter the password: ");
  scanf("%d", &input);
  sleep(1);

  if (check==input)
     print_good();
  else
     print_again();
  return 0;
}
