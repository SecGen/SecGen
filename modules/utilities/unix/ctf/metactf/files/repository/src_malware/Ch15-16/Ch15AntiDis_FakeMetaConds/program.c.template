#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <string.h>
#include <sys/ptrace.h>
#include <unistd.h>
#define USERDEF0 AAAAAA
#define USERDEF1 BBBBBB
#define USERDEF2 CCCCCC
#define USERDEF3 DDDDDD
#define USERDEF4 EEEEEE

/* EB=JMP	72=JC	73=JNC	74=JZ/JE	75=JNZ/JNE */
/* All use a garbage 0F (Can use E8=CALL as well) */

/* JMP +1; (EB01) */
#define ASM0 asm volatile ( \
	"  .byte 0xEB 		\n"	    \
	"  .byte 0x01 		\n"	    \
	"  .byte 0x0F	\n")

/* JZ +3/JNZ +1; (7403,7501) */
#define ASM1 asm volatile ( \
	"  .byte 0x74 		\n"	    \
	"  .byte 0x03 		\n"	    \
	"  .byte 0x75 		\n"	    \
	"  .byte 0x01 		\n"	    \
	"  .byte 0x0F	\n")

/* Fake CMP/JZ +1; (7401) */
#define ASM2 asm volatile ( \
        "  pushl %eax       \n"        \
	"  cmpl  %eax, %eax \n"        \
	"  .byte 0x74	    \n"	\
	"  .byte 0x01	    \n"	\
	"  .byte 0x0F       \n"        \
	"  popl  %eax       \n")

/* Fake XOR/JE +1 (7401) */
#define ASM3 asm volatile ( \
	"push %eax	\n"	   \
	"xor %eax, %eax \n"	   \
	".byte 0x74	\n"	   \
	".byte 0x01	\n"	   \
	".byte 0x0F	\n"	   \
	"pop %eax	\n")

/* Fake STC/JC +1 (7201) */
#define ASM4 asm(\
	" stc			\n"	\
	" .byte 0x72		\n"	\
	" .byte 0x01		\n"	\
	" .byte 0x0F		\n")

/* Fake STC/CMC/JNC +1 (7301) */
#define ASM5 asm(\
	" stc			\n"	\
	" cmc			\n"	\
	" .byte 0x73		\n"	\
	" .byte 0x01		\n"	\
	" .byte 0x0F		\n")

/* Fake CLC/JNC +1 (7301) */
#define ASM6 asm(\
	" clc			\n"	\
	" .byte 0x73		\n"	\
	" .byte 0x01		\n"	\
	" .byte 0x0F		\n")

/* Fake CLC/JC +1 (7301) */
#define ASM7 asm(\
	" clc			\n"	\
	" cmc			\n"	\
	" .byte 0x72		\n"	\
	" .byte 0x01		\n"	\
	" .byte 0x0F		\n")

char msg[] =
 "In this level, a variety of anti-disassembly techniques are used to hide\n"
 "the instructions that are being executed.  Bypass each by setting the\n"
 "appropriate bytes to data in IDA Pro.  By redefining these bytes, one can\n"
 "expose the actual assembly instructions being executed. Once exposed, you\n"
 "can find the integer that is being used as the password and complete the\n"
 "level.  We have disabled disabled debuggers to ensure the solution is found\n"
 "via disassembly.\n\n";

/* Symbolic execution trap */
void print_msg() {
  unsigned int i,h1,h2;
  unsigned int len=strlen(msg);
  for (i = 0; i < 100*len; i++) {
    h1 += msg[i%len] + msg[(i+1)%len];
    h2 += msg[(i+1)%len] + msg[(i+2)%len];
  }
  if (h1 == h2)
    printf("%s",msg);
  else
    printf("%s",msg);
}

void print_good(void){
	    printf("Good Job.\n");
		printflag();
}

void print_again(void){
		printf("Try again.\n");
}

void detectTrace(void) __attribute__((constructor));
void detectTrace (void) {
    if(ptrace(PTRACE_TRACEME, 0, 1, 0) < 0) {
        printf("Sorry, we have disallowed debuggers on this assignment.\n");
        exit(1);
    };
};

void printflag()
{
	int fd;
	int len;
	unsigned char data[128];

	fd = open("flag", O_RDONLY);

	if ( fd <= 0 ) {
		printf("Failed to open flag.\n");
		return;
	}

	len = lseek( fd, 0, SEEK_END);
	lseek(fd, 0, SEEK_SET);

	if ( len > 128 ) {
		len = 128;
	}

	memset(data, 0, 128);
	read( fd, data, len);
	close(fd);

	printf("%s\n", data);
	return;
}

int main (int argc, char** argv) {

    int input,check;

/*  NOP_PAD1
    NOP_PAD2
    NOP_PAD3 */

    print_msg();

    USERDEF0;
    check=USERDEF4;

    printf("Enter the password: ");
    scanf("%d", &input);

    USERDEF1;
    check++;

    USERDEF2;
    check++;

    sleep(1);

    USERDEF3;
    if (check==input)
	print_good();
    else
	print_again();
    return 0;
}
