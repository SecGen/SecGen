/* Adapted from Shu Ping Chu CS 492/592 Winter 2017
   1. Use IDA to bypass anti-disassembly to find address of ptrace call
   2. Set breakpoint at ptrace function, and run
	b *ptrace
	run
   3. Can immediately return using command
	ret

    Make selected stack frame return now? (y or n) y

   4. Then we need to set $eax to 0
        set $eax=0

   5. Then pull params out of subsequent strcmp call
*/
#include <stdio.h>
#include <fcntl.h>
#include <string.h>
#include <sys/ptrace.h>
#include <unistd.h>
#include <stdlib.h>
#include <time.h>
#define USERDEF "AAAAAA"

#define CALL_PTRACE asm volatile ( \
	"  pushl $0x1 \n" \
	"  pushl $0x0 \n" \
	"  pushl $0x0 \n" \
	"  jmp cpta+1 \n" \
	"cpta: .byte 0xe9 \n" \
	"  call ptrace \n" \
	"  addl $0x10, %esp \n"\
	"  test %eax, %eax \n"\
	"  jns cont \n"\
	"  jmp cptb+1 \n" \
	"cptb: .byte 0xe9 \n" \
	"  call ndb \n"\
	"cont: \n"\
	"  nop \n")

typedef enum { false = 0, true = !false } bool;

char msg[] = \
"This level employs both anti-disassembly and anti-debugging techniques\n\
to foil analysis.  Within a disassembler, undo the anti-disassembly\n\
to identify the location in the binary that uses the ptrace call to\n\
detect whether a debugger is attached.  Bypass this check and then set\n\
a breakpoint at the call to strcmp to discover the password.\n\n";

/* Symbolic execution trap */
void print_msg() {
  unsigned int i,h1,h2;
  unsigned int len=strlen(msg);
  for (i = 0; i < 100*len; i++) {
    h1 += msg[i%len] + msg[(i+1)%len];
    h2 += msg[(i+1)%len] + msg[(i+2)%len];
  }
  if (h1 == h2)
    printf("%s",msg);
  else
    printf("%s",msg);
}

void ndb() {
    printf("Debuggers and tracing not allowed.\n");
    exit(0);
}

void printflag()
{
	int fd;
	int len;
	unsigned char data[128];

	fd = open("flag", O_RDONLY);

	if ( fd <= 0 ) {
		printf("Failed to open flag.\n");
		return;
	}

	len = lseek( fd, 0, SEEK_END);
	lseek(fd, 0, SEEK_SET);

	if ( len > 128 ) {
		len = 128;
	}

	memset(data, 0, 128);
	read( fd, data, len);
	close(fd);

	printf("%s\n", data);
	return;
}

int main(int argc, char* argv[]) {

    char buff[20];
    char pass[20];
    char c;
    int i;

    print_msg();

    for (i=0; i < 20; i++)
	pass[i] = 0;
    strncpy(pass,USERDEF,strlen(USERDEF));

    c = pass[0];
    pass[0] = pass[2];
    pass[2] = c;

    CALL_PTRACE;

    sleep(1);
    printf("Enter the password: ");
    scanf("%20s",buff);

    /* printf("pass is: %s,  buff is: %s\n",pass,buff);*/
    if (strcmp(buff,pass))
	printf ("Try again.\n");
    else
        printflag();
    return 0;
}

